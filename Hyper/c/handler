/* Copyright (C) Acorn Computers Ltd 1994 */

/* include standard C definitions */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "swis.h"

/* include event lib declarations */

#include "event.h"
#include "wimplib.h"

/* include renderlib stuff */

#include "drawfile.h"

/* include toolbox lib declarations */

#include "toolbox.h"
#include "window.h"
#include "gadgets.h"
#include "menu.h"
#include "scale.h"
#include "quit.h"
#include "proginfo.h"
#include "printdbox.h"
#include "iconbar.h"

/* include application definitions */

#include "hyper.h"
#include "button.h"
#include "draw.h"
#include "handler.h"
#include "events.h"
#include "utils.h"
#include "comps.h"
#include "commands.h"
#include "hcl.h"

extern Viewer *views;

/* handlers...*/

/* when the viewer window is closed, free up the data it used. When we registered
   this handler, we passed in the viewer structure pointer as the handle. */

int hide_viewer(int event_code, WimpPollBlock *event,IdBlock *id_block,void *h)
{
   Viewer *v = (Viewer *)h;
   IGNORE(event_code);
   IGNORE(event);
   IGNORE(id_block);

   do_clear(v,0);
   return 1;

}

/*
   we could have registered separate handlers for each of these events, but as
   minimal functionality is carried out for each of them, its probably more
   efficient to switch.
 */

int misc_handler(int event_code, ToolboxEvent *event,IdBlock *id_block,void *h)
{
   Viewer *view;
   IGNORE(h);
   IGNORE(event);

   switch(event_code) {
      case HomeButtonEvent:
      case BackButtonEvent:

         /* both the toolbar and the viewer window have the same client
            handle. It points to our viewer structure */

         toolbox_get_client_handle(0,id_block->self_id, (void **) &view);
         if (!view) toolbox_get_client_handle(0,id_block->parent_id, (void **) &view);

         if (event_code == BackButtonEvent)
            commands_goto_last(view);
         else command_parse(view,NULL);
         break;


      default:
         /* didn't use it */
         return 0;
      }
   return 1;
}

/* make sure that the 'Status line' entry on the viewer menu is ticked
   correctly */

int menu_setup(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{
   Viewer *v;

   IGNORE(event_code);
   IGNORE(event);
   IGNORE(handle);

   toolbox_get_client_handle(0,id_block->ancestor_id,(void **) &v);
   menu_set_tick(0,id_block->self_id, ShowStatusEntry,v->flags & ViewerFlag_StatusLine);

   return 1;
}

/* this is called when the find dialogue is acknowledged */

int search_handler(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{
   Viewer *v;
   int grp;
   char buf[256];

   IGNORE(event_code);
   IGNORE(event);
   IGNORE(handle);

   /* what viewer's stack do we want to search ? */
   toolbox_get_client_handle(0,id_block->ancestor_id,(void **) &v);

   radiobutton_get_state(0,id_block->self_id,6,0,&grp);
   writablefield_get_value(0,id_block->self_id,3,buf,256,0);

   if (grp) commands_search(v,0,0,buf);
   else commands_search(v,0,1,buf);
   return 1;

}

/* this is called when the user clicks on the 'Status line' menu entry or
   presses 's' over the viewer */

int toggle_status(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{
   Viewer *v;
   int status;
   IGNORE(event_code);
   IGNORE(event);
   IGNORE(handle);

   if (id_block->self_component == -1) {
        /* must have been a keyboard shortcut */
      toolbox_get_client_handle(0,id_block->self_id,(void **) &v);
   } else {
        /* came from menu */
      toolbox_get_client_handle(0,id_block->ancestor_id,(void **) &v);
      menu_set_tick(0,id_block->self_id, id_block->self_component,1 - (v->flags & ViewerFlag_StatusLine));
   }

   status = 1 - (v->flags & ViewerFlag_StatusLine);
   v->flags = (v->flags & ~ViewerFlag_StatusLine) | status;

   if (status) toolbox_show_object(0,v->status,0,0,id_block->ancestor_id,-1);
   else toolbox_hide_object(0,v->status);

   return 1;
}

static int button_click(Viewer *v,ComponentId b)
{
   HotSpot *button;

   button = v->buttons;

   while (button) {
     if(button->id == b) {
       do_goto(v,button->command);
       v->cname = button->name;
       break;
     }
     button = button->next;
   }

   return SUCCESS;
}


int click_viewer(int event_code, WimpPollBlock *event,IdBlock *id_block,void *h)
{
    Viewer *view = (Viewer *)h;
    IGNORE(event);
    IGNORE(event_code);

    if (event->mouse_click.buttons & Wimp_MouseButtonMenu) return 1;

    /* need to put caret back into viewer if SELECT or ADJUST, but not MENU*/

    wimp_set_caret_position(view->wimpw,-1,1<<25,-1,0,0);
                                        /* no icon */
                                          /* invisible */

    /* fire off hot spot */
    button_click(view,id_block->self_component);

    return 1;
}

extern int quit;

extern Viewer *load_hcl_file(char *n);

int tbquit_handler(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{
  IGNORE(event);
  IGNORE(event_code);
  IGNORE(handle);
  IGNORE(id_block);

  quit =1;
  return 1;
}

int print_card(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{

  PrintDboxPrintEvent *print = (PrintDboxPrintEvent *)event;
  Viewer *v;
  IGNORE(handle);
  IGNORE(event_code);

  toolbox_get_client_handle(0,id_block->ancestor_id,(void **) &v);

  print_it(v,print->copies,print->scale_factor,
                event->hdr.flags & PrintDboxEvents_PrintSave_Sideways);

  return 1;
}

int proginfo_show(int event_code, ToolboxEvent  *event, IdBlock *id_block,
                   void  *handle)
{

    IGNORE(handle);
    IGNORE(event);
    IGNORE(event_code);

    proginfo_set_version(0,id_block->self_id,lookup_token("Version"));

    return 1;
}

int quit_handler(WimpMessage *message, void *handle)
{
  IGNORE(message);
  IGNORE(handle);

  quit =1;
  return 1;
}

